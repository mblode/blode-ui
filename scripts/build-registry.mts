import { existsSync, promises as fs } from "node:fs";
import { tmpdir } from "node:os";
import path from "node:path";
import { rimraf } from "rimraf";
import {
  registryItemSchema,
  type registryItemTypeSchema,
  registrySchema,
} from "shadcn/schema";
import { Project, ScriptKind } from "ts-morph";
import type { z } from "zod";

type Registry = z.infer<typeof registrySchema>;

import { registry } from "../registry/index";
import { styles } from "../registry/registry-styles";
import { fixImport } from "./fix-import.mts";

const REGISTRY_PATH = path.join(process.cwd(), "public/r");

const REGISTRY_INDEX_WHITELIST: z.infer<typeof registryItemTypeSchema>[] = [
  "registry:ui",
  "registry:lib",
  "registry:block",
];

const project = new Project({
  compilerOptions: {},
});

async function createTempSourceFile(filename: string) {
  const dir = await fs.mkdtemp(path.join(tmpdir(), "blode-"));
  return path.join(dir, filename);
}

// ----------------------------------------------------------------------------
// Build __registry__/index.tsx.
// ----------------------------------------------------------------------------
async function buildRegistry(registry: Registry) {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import React from "react";

const isRenderableComponent = (value: unknown) => {
  if (typeof value === "function") {
    return true;
  }

  return (
    typeof value === "object" &&
    value !== null &&
    "$$typeof" in (value as Record<string, unknown>)
  );
};

const resolveRegistryComponent = (mod: Record<string, unknown>) => {
  if (isRenderableComponent(mod.default)) {
    return mod.default;
  }

  for (const [key, value] of Object.entries(mod)) {
    if (key === "__esModule") {
      continue;
    }

    if (isRenderableComponent(value)) {
      return value;
    }
  }

  return () => null;
};

export const Index: Record<string, unknown> = {
`;

  for (const style of styles) {
    index += `  "${style.name}": {`;

    // Build style index.
    for (const item of registry.items) {
      const resolveFiles = item.files?.map(
        (file) =>
          `registry/${style.name}/${
            typeof file === "string" ? file : file.path
          }`
      );
      if (!resolveFiles) {
        continue;
      }

      const type = item.type.split(":")[1];
      let sourceFilename = "";

      if (item.type === "registry:block") {
        const file = resolveFiles[0];
        const filename = path.basename(file);
        let raw: string;
        try {
          raw = await fs.readFile(file, "utf8");
        } catch (_error) {
          continue;
        }
        const tempFile = await createTempSourceFile(filename);
        const sourceFile = project.createSourceFile(tempFile, raw, {
          scriptKind: ScriptKind.TSX,
        });

        // Write the source file for blocks only.
        sourceFilename = `__registry__/${style.name}/${type}/${item.name}.tsx`;

        if (item.files) {
          const files = item.files.map((file) =>
            typeof file === "string"
              ? { type: "registry:page", path: file }
              : file
          );
          if (files?.length) {
            sourceFilename = `__registry__/${style.name}/${files[0].path}`;
          }
        }

        const sourcePath = path.join(process.cwd(), sourceFilename);
        if (!existsSync(sourcePath)) {
          await fs.mkdir(sourcePath, { recursive: true });
        }

        rimraf.sync(sourcePath);
        await fs.writeFile(sourcePath, sourceFile.getText());
      }

      let componentPath = `@/registry/${style.name}/${type}/${item.name}`;

      if (item.files) {
        const files = item.files.map((file) =>
          typeof file === "string"
            ? { type: "registry:page", path: file }
            : file
        );
        if (files?.length) {
          componentPath = `@/registry/${style.name}/${files[0].path}`;
        }
      }

      index += `
    "${item.name}": {
      name: "${item.name}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: [${item.files?.map((file) => {
        const filePath = `registry/${style.name}/${
          typeof file === "string" ? file : file.path
        }`;
        const resolvedFilePath = path.resolve(filePath);
        return typeof file === "string"
          ? `"${resolvedFilePath}"`
          : `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ""}"
      }`;
      })}],
      categories: ${JSON.stringify(item.categories)},
      component: React.lazy(() =>
        import("${componentPath}").then((mod) => ({
          default: resolveRegistryComponent(mod as Record<string, unknown>),
        }))
      ),
      source: "${sourceFilename}",
      meta: ${JSON.stringify(item.meta)},
    },`;
    }

    index += `
  },`;
  }

  index += `
}
`;

  // ----------------------------------------------------------------------------
  // Build registry/index.json.
  // ----------------------------------------------------------------------------
  const items = registry.items
    .filter((item) => ["registry:ui"].includes(item.type))
    .map((item) => {
      return {
        ...item,
        files: item.files?.map((_file) => {
          const file =
            typeof _file === "string"
              ? {
                  path: _file,
                  type: item.type,
                }
              : _file;

          return file;
        }),
      };
    });
  const registryJson = JSON.stringify(items, null, 2);
  rimraf.sync(path.join(REGISTRY_PATH, "index.json"));
  await fs.writeFile(
    path.join(REGISTRY_PATH, "index.json"),
    registryJson,
    "utf8"
  );

  // Write style index.
  rimraf.sync(path.join(process.cwd(), "__registry__/index.tsx"));
  await fs.writeFile(path.join(process.cwd(), "__registry__/index.tsx"), index);
}

// ----------------------------------------------------------------------------
// Build registry/styles/[style]/[name].json.
// ----------------------------------------------------------------------------
async function buildStyles(registry: Registry) {
  for (const style of styles) {
    const targetPath = path.join(REGISTRY_PATH, "styles", style.name);

    // Clean and recreate output directory to remove stale files.
    rimraf.sync(targetPath);
    await fs.mkdir(targetPath, { recursive: true });

    for (const item of registry.items) {
      if (!REGISTRY_INDEX_WHITELIST.includes(item.type)) {
        continue;
      }

      const files = item.files
        ? await Promise.all(
            item.files.map(async (_file) => {
              const file =
                typeof _file === "string"
                  ? {
                      path: _file,
                      type: item.type,
                      content: "",
                      target: "",
                    }
                  : _file;

              let content: string;
              try {
                content = await fs.readFile(
                  path.join(process.cwd(), "registry", style.name, file.path),
                  "utf8"
                );

                content = fixImport(content);
              } catch (_error) {
                return;
              }

              const tempFile = await createTempSourceFile(file.path);
              const sourceFile = project.createSourceFile(tempFile, content, {
                scriptKind: ScriptKind.TSX,
              });

              sourceFile.getVariableDeclaration("iframeHeight")?.remove();
              sourceFile.getVariableDeclaration("containerClassName")?.remove();
              sourceFile.getVariableDeclaration("description")?.remove();

              let target = file.target || "";

              if ((!target || target === "") && item.name.startsWith("v0-")) {
                const fileName = file.path.split("/").pop();
                if (
                  file.type === "registry:component" ||
                  file.type === "registry:example"
                ) {
                  target = `components/${fileName}`;
                }

                if (file.type === "registry:ui") {
                  target = `components/ui/${fileName}`;
                }

                if (file.type === "registry:lib") {
                  target = `lib/${fileName}`;
                }
              }

              return {
                path: file.path,
                type: file.type,
                content: sourceFile.getText(),
                target,
              };
            })
          )
        : undefined;

      const payload = registryItemSchema.safeParse({
        $schema: "https://ui.blode.co/schema/registry-item.json",
        author: "Matthew Blode",
        ...item,
        files,
      });

      if (payload.success) {
        await fs.writeFile(
          path.join(targetPath, `${item.name}.json`),
          JSON.stringify(payload.data, null, 2),
          "utf8"
        );
      } else {
        console.warn(
          `âš ï¸  Validation failed for ${item.name}:`,
          payload.error.format()
        );
      }
    }
  }

  // ----------------------------------------------------------------------------
  // Build registry/styles/index.json.
  // ----------------------------------------------------------------------------
  const stylesJson = JSON.stringify(styles, null, 2);
  await fs.writeFile(
    path.join(REGISTRY_PATH, "styles/index.json"),
    stylesJson,
    "utf8"
  );
}

// ----------------------------------------------------------------------------
// Build registry.json for shadcn registry directory submission.
// ----------------------------------------------------------------------------
async function buildRegistryJson(registry: Registry) {
  const items = registry.items
    .filter((item) => REGISTRY_INDEX_WHITELIST.includes(item.type))
    .map((item) => ({
      name: item.name,
      type: item.type,
      ...(item.title ? { title: item.title } : {}),
      ...(item.description ? { description: item.description } : {}),
      ...(item.dependencies?.length ? { dependencies: item.dependencies } : {}),
      ...(item.registryDependencies?.length
        ? { registryDependencies: item.registryDependencies }
        : {}),
      files: item.files?.map((_file) => {
        const file =
          typeof _file === "string"
            ? { path: _file, type: item.type }
            : { path: _file.path, type: _file.type };

        return {
          path: `registry/default/${file.path}`,
          type: file.type,
        };
      }),
    }));

  const payload = {
    $schema: "https://ui.shadcn.com/schema/registry.json",
    name: registry.name,
    homepage: registry.homepage,
    items,
  };

  await fs.writeFile(
    path.join(REGISTRY_PATH, "registry.json"),
    JSON.stringify(payload, null, 2),
    "utf8"
  );
}

// ----------------------------------------------------------------------------
// Build public/r/[name].json (flat component files for directory submission).
// ----------------------------------------------------------------------------
async function buildFlatFiles(registry: Registry) {
  // Clean stale flat files first.
  const existingFiles = await fs.readdir(REGISTRY_PATH);
  for (const file of existingFiles) {
    if (
      file.endsWith(".json") &&
      file !== "index.json" &&
      file !== "registry.json"
    ) {
      rimraf.sync(path.join(REGISTRY_PATH, file));
    }
  }

  for (const style of styles) {
    const stylePath = path.join(REGISTRY_PATH, "styles", style.name);

    for (const item of registry.items) {
      if (!REGISTRY_INDEX_WHITELIST.includes(item.type)) {
        continue;
      }

      const sourceFile = path.join(stylePath, `${item.name}.json`);
      const targetFile = path.join(REGISTRY_PATH, `${item.name}.json`);

      if (existsSync(sourceFile)) {
        await fs.copyFile(sourceFile, targetFile);
      }
    }
  }
}

// ----------------------------------------------------------------------------
// Build registry/styles/[name]/index.json.
// ----------------------------------------------------------------------------
async function buildStylesIndex() {
  for (const style of styles) {
    const targetPath = path.join(REGISTRY_PATH, "styles", style.name);

    const payload: z.infer<typeof registryItemSchema> = {
      name: style.name,
      type: "registry:style",
      dependencies: [
        "tw-animate-css",
        "class-variance-authority",
        "blode-icons-react",
      ],
      registryDependencies: ["utils"],
      cssVars: {},
      files: [],
    };

    await fs.writeFile(
      path.join(targetPath, "index.json"),
      JSON.stringify(payload, null, 2),
      "utf8"
    );
  }
}

try {
  const start = Date.now();
  console.log("ðŸ’½ Building registry...");
  const result = registrySchema.safeParse(registry);

  if (!result.success) {
    console.error("Registry validation failed:");
    console.error(result.error.format());
    process.exit(1);
  }

  await buildRegistry(result.data);
  await buildStyles(result.data);
  await buildStylesIndex();
  await buildRegistryJson(result.data);
  await buildFlatFiles(result.data);

  const elapsed = ((Date.now() - start) / 1000).toFixed(2);
  console.log(`âœ… Done in ${elapsed}s!`);
} catch (error) {
  console.error(error);
  process.exit(1);
}
